
╔══════════════════════════════════════════════════════════════════╗
║     4-WAY SET-ASSOCIATIVE CACHE SIMULATION                       ║
║     Cache: 1KB (8 sets × 4 ways × 32B lines)                     ║
║     Replacement: Random (LFSR)  |  Write Policy: Write-back      ║
╚══════════════════════════════════════════════════════════════════╝

VCD info: dumpfile cache_sim.vcd opened for output.
════════════════════════════════════════════════════════════════════
TEST 1: CACHE HIT LATENCY DEMONSTRATION
════════════════════════════════════════════════════════════════════
[CPU] Read request: addr=0x00100 (first access - MISS expected)
    [MEM] Request: addr=0x00008 rw=     READ
    [MEM] Read complete: addr=0x00008
  Result: MISS | Latency: 57 cycles | Data: 0x00000008
[CPU] Read request: addr=0x00100 (same address - HIT expected)
  Result: HIT  | Latency: 3 cycles | Data: 0x00000008
[CPU] Read request: addr=0x00104 (same line - HIT expected)
  Result: HIT  | Latency: 3 cycles | Data: 0x00000008

>>> Hit Latency: 1 cycle | Miss Penalty: ~50 cycles (memory latency)

════════════════════════════════════════════════════════════════════
TEST 2: DATA SIZE SUPPORT (BYTE / HALF-WORD / WORD)
════════════════════════════════════════════════════════════════════
    [MEM] Request: addr=0x00010 rw=     READ
    [MEM] Read complete: addr=0x00010
[CPU] Write BYTE to 0x00200: data=0xAB
  Result:  HIT
[CPU] Write HALF-WORD to 0x00202: data=0xCDEF
  Result:  HIT
[CPU] Write WORD to 0x00204: data=0x12345678
  Result:  HIT
[CPU] Read WORD from 0x00204:
  Result:  HIT | Data: 0x12345678 (expected: 0x12345678)

════════════════════════════════════════════════════════════════════
TEST 3: CONFLICT MISSES DEMONSTRATION
════════════════════════════════════════════════════════════════════
Cache has 8 sets × 4 ways. Accessing 5 addresses mapping to same set
will cause conflict misses (exceeds 4-way associativity).

Address mapping: Set = (addr >> 5) & 0x7
Addresses that map to SET 0: 0x00000, 0x00100, 0x00200, 0x00300, 0x00400
(all have bits [7:5] = 000)

--- Phase 1: Fill all 4 ways of Set 0 ---
[CPU] Read addr=0x00000000 (Set 0, Way 0)
    [MEM] Request: addr=0x00000 rw=     READ
    [MEM] Read complete: addr=0x00000
  Result: MISS | Latency: 57 cycles
[CPU] Read addr=0x00000100 (Set 0, Way 1)
  Result: HIT  | Latency: 3 cycles
[CPU] Read addr=0x00000200 (Set 0, Way 2)
  Result: HIT  | Latency: 3 cycles
[CPU] Read addr=0x00000300 (Set 0, Way 3)
    [MEM] Request: addr=0x00018 rw=     READ
    [MEM] Read complete: addr=0x00018
  Result: MISS | Latency: 57 cycles

--- Phase 2: Access 5th address (CONFLICT MISS - evicts one way) ---
[CPU] Read addr=0x00000400 (Set 0, 5th block - causes eviction!)
    [MEM] Request: addr=0x00020 rw=     READ
    [MEM] Read complete: addr=0x00020
  Result: MISS | Latency: 57 cycles

--- Phase 3: Re-access evicted address (CONFLICT MISS) ---
[CPU] Read addr=0x00000000 (was in Set 0, but may be evicted)
    [MEM] Request: addr=0x00040 rw=WRITE(WB)
    [MEM] Writeback complete: addr=0x00040
    [MEM] Request: addr=0x00000 rw=     READ
    [MEM] Read complete: addr=0x00000
  Result: MISS | Latency: 111 cycles

>>> Statistics: Hits=2, Misses=4
>>> This demonstrates CONFLICT MISSES due to limited associativity

════════════════════════════════════════════════════════════════════
TEST 4: MEMORY WRITE-BACK (DIRTY LINE EVICTION)
════════════════════════════════════════════════════════════════════
Write-back cache: dirty lines written to memory on eviction

--- Step 1: Write data to create dirty line ---
[CPU] Write addr=0x00001000 data=0xDEADBEEF
    [MEM] Request: addr=0x00080 rw=     READ
    [MEM] Read complete: addr=0x00080
  Result: MISS (line is now DIRTY)

--- Step 2: Force eviction by filling the set ---
[CPU] Read addr=0x00001100 (filling set to force eviction)
    [MEM] Request: addr=0x00088 rw=     READ
    [MEM] Read complete: addr=0x00088
  Result: MISS
[CPU] Read addr=0x00001200 (filling set to force eviction)
    [MEM] Request: addr=0x00090 rw=     READ
    [MEM] Read complete: addr=0x00090
  Result: MISS
[CPU] Read addr=0x00001300 (filling set to force eviction)
    [MEM] Request: addr=0x00098 rw=     READ
    [MEM] Read complete: addr=0x00098
  Result: MISS
[CPU] Read addr=0x00001400 (filling set to force eviction)
    [MEM] Request: addr=0x000a0 rw=     READ
    [MEM] Read complete: addr=0x000a0
  Result: MISS

>>> If WRITE(WB) appeared in memory log, write-back occurred!

════════════════════════════════════════════════════════════════════
TEST 5: SEQUENTIAL ACCESS PATTERN (Good Locality)
════════════════════════════════════════════════════════════════════
Accessing 32 consecutive words (spans multiple lines):
    [MEM] Request: addr=0x00100 rw=     READ
    [MEM] Read complete: addr=0x00100
    [MEM] Request: addr=0x00101 rw=     READ
    [MEM] Read complete: addr=0x00101
    [MEM] Request: addr=0x00102 rw=     READ
    [MEM] Read complete: addr=0x00102
    [MEM] Request: addr=0x00103 rw=     READ
    [MEM] Read complete: addr=0x00103
  Total: Hits=28, Misses=4
  Hit Rate: 87%
  Avg Hit Latency: 2 cycles
  Avg Miss Latency: 56 cycles

════════════════════════════════════════════════════════════════════
TEST 6: WRITE THEN READ VERIFICATION
════════════════════════════════════════════════════════════════════
[CPU] Write addr=0x03000 data=0xCAFEBABE
    [MEM] Request: addr=0x00180 rw=     READ
    [MEM] Read complete: addr=0x00180
[CPU] Read addr=0x03000
  Read data: 0xcafebabe
  >>> PASS: Data matches!

[CPU] Write addr=0x03004 data=0x12345678
[CPU] Read addr=0x03004
  Read data: 0x12345678
  >>> PASS: Data matches!

════════════════════════════════════════════════════════════════════
TEST 7: THRASHING PATTERN (Worst Case - Repeated Conflicts)
════════════════════════════════════════════════════════════════════
Repeatedly accessing 5 addresses mapping to same set (4-way cache):
This causes continuous evictions (thrashing)

    [MEM] Request: addr=0x00200 rw=WRITE(WB)
    [MEM] Writeback complete: addr=0x00200
    [MEM] Request: addr=0x00200 rw=     READ
    [MEM] Read complete: addr=0x00200
    [MEM] Request: addr=0x00208 rw=     READ
    [MEM] Read complete: addr=0x00208
    [MEM] Request: addr=0x00210 rw=     READ
    [MEM] Read complete: addr=0x00210
    [MEM] Request: addr=0x00218 rw=     READ
    [MEM] Read complete: addr=0x00218
    [MEM] Request: addr=0x00220 rw=     READ
    [MEM] Read complete: addr=0x00220
    [MEM] Request: addr=0x00208 rw=     READ
    [MEM] Read complete: addr=0x00208
    [MEM] Request: addr=0x00210 rw=     READ
    [MEM] Read complete: addr=0x00210
    [MEM] Request: addr=0x00220 rw=     READ
    [MEM] Read complete: addr=0x00220
    [MEM] Request: addr=0x00600 rw=WRITE(WB)
    [MEM] Writeback complete: addr=0x00600
    [MEM] Request: addr=0x00200 rw=     READ
    [MEM] Read complete: addr=0x00200
    [MEM] Request: addr=0x00218 rw=     READ
    [MEM] Read complete: addr=0x00218
    [MEM] Request: addr=0x00200 rw=     READ
    [MEM] Read complete: addr=0x00200
    [MEM] Request: addr=0x00208 rw=     READ
    [MEM] Read complete: addr=0x00208
    [MEM] Request: addr=0x00220 rw=     READ
    [MEM] Read complete: addr=0x00220
  Results: Hits=7, Misses=13
  Hit Rate: 35% (expected low due to thrashing)

════════════════════════════════════════════════════════════════════
TEST 8: NON-BLOCKING CACHE BEHAVIOR (MSHR DEMONSTRATION)
════════════════════════════════════════════════════════════════════
Non-blocking cache uses MSHR (Miss Status Holding Register) to:
  - Track outstanding memory requests
  - Allow cache to continue processing after miss is issued
  - Handle memory response asynchronously

--- Scenario 1: Miss triggers MSHR allocation ---
[CPU] Read addr=0x00005000 (cache miss expected)
  MSHR will: 1) Store miss info  2) Issue memory request  3) Block CPU
    [MEM] Request: addr=0x00280 rw=     READ
    [MEM] Read complete: addr=0x00280
  Result: MISS | MSHR handled the miss

--- Scenario 2: Hit while MSHR was previously active ---
[CPU] Read addr=0x00005000 (same line - should hit now)
  Result:  HIT | Latency: 3 cycles (fast - data in cache)

--- Scenario 3: Write miss with MSHR (allocate-on-write) ---
[CPU] Write addr=0x00006000 data=0xABCD1234 (write miss)
  MSHR will: 1) Fetch line  2) Merge write data  3) Mark dirty
    [MEM] Request: addr=0x00300 rw=     READ
    [MEM] Read complete: addr=0x00300
  Result: MISS
[CPU] Read addr=0x00006000 (verify write)
  Data: 0xabcd1234 (CORRECT)

--- Scenario 4: MSHR with dirty line eviction (write-back) ---
[CPU] Write addr=0x00007000 data=0xDEAD0001 (create dirty line)
    [MEM] Request: addr=0x00380 rw=     READ
    [MEM] Read complete: addr=0x00380
[CPU] Accessing addresses to force eviction of dirty line...
  MSHR will: 1) Write-back dirty  2) Fetch new line  3) Complete
    [MEM] Request: addr=0x00c00 rw=WRITE(WB)
    [MEM] Writeback complete: addr=0x00c00
    [MEM] Request: addr=0x00388 rw=     READ
    [MEM] Read complete: addr=0x00388
    [MEM] Request: addr=0x00390 rw=     READ
    [MEM] Read complete: addr=0x00390
    [MEM] Request: addr=0x00398 rw=     READ
    [MEM] Read complete: addr=0x00398
    [MEM] Request: addr=0x003a0 rw=     READ
    [MEM] Read complete: addr=0x003a0
  If [MEM] WRITE(WB) appeared above, MSHR handled write-back correctly

--- Scenario 5: MSHR state transitions ---
MSHR State Machine:
  IDLE -> MISS_PENDING: On cache miss, MSHR allocated
  MISS_PENDING -> WB_PENDING: If evicting dirty line
  WB_PENDING -> FETCH_PENDING: After write-back complete
  FETCH_PENDING -> IDLE: After line fetched, request complete

--- Scenario 6: MSHR timing demonstration ---
[CPU] Read addr=0x00008000 @ cycle 2427
    [MEM] Request: addr=0x00e00 rw=WRITE(WB)
    [MEM] Writeback complete: addr=0x00e00
    [MEM] Request: addr=0x00400 rw=     READ
    [MEM] Read complete: addr=0x00400
  Response @ cycle 2538 (total latency: 111 cycles)
  Breakdown: ~1 cycle miss detect + 50 cycle mem latency + 1 cycle response

>>> NON-BLOCKING SUMMARY:
    - MSHR tracks one outstanding miss at a time
    - Handles read misses, write misses, and write-backs
    - Memory requests issued asynchronously
    - Cache returns response when memory completes

════════════════════════════════════════════════════════════════════
TEST 9: HIT-UNDER-MISS (True Non-Blocking Behavior)
════════════════════════════════════════════════════════════════════
This test verifies the cache can service HITS while a MISS is pending.
A blocking cache would stall all requests during memory fetch.

--- Setup: Pre-load cache lines in different sets ---
    [MEM] Request: addr=0x00001 rw=     READ
    [MEM] Read complete: addr=0x00001
    [MEM] Request: addr=0x00002 rw=     READ
    [MEM] Read complete: addr=0x00002
    [MEM] Request: addr=0x00003 rw=     READ
    [MEM] Read complete: addr=0x00003
  Loaded lines at 0x00020 (Set 1), 0x00040 (Set 2), 0x00060 (Set 3)

--- Hit-Under-Miss Test ---
1. Issue READ MISS to trigger memory fetch (takes 50 cycles)
2. While miss pending, issue HITs to other cached lines
3. Hits should complete in 1 cycle, not wait for miss

[CPU] @ cycle 2709: Issue MISS to addr=0x00009000
    [MEM] Request: addr=0x00480 rw=     READ
[CPU] @ cycle 2713: MISS still pending (MSHR busy)...
      Now issuing HITs to pre-loaded lines:
      cpu_req_ready = 1 (accepting requests!)
      HIT 0x00020:  HIT in 3 cycles
      HIT 0x00040:  HIT in 3 cycles
      HIT 0x00060:  HIT in 3 cycles
[CPU] @ cycle 2723: Original MISS completed

>>> SUCCESS: 3 hits serviced WHILE miss was pending!
>>> This is TRUE NON-BLOCKING (hit-under-miss) behavior!

════════════════════════════════════════════════════════════════════
TEST 10: MISS-UNDER-MISS (Multi-MSHR - 4 Entries)
════════════════════════════════════════════════════════════════════
This test verifies MULTIPLE OUTSTANDING MISSES can be tracked.
With 4 MSHR entries, we can issue up to 4 misses before blocking.

--- Issue 4 MISSES rapidly (should all be accepted) ---
[CPU] @ cycle 2723: Issue MISS #1 to addr=0x0000c000, ready=1
[CPU] @ cycle 2725: Issue MISS #2 to addr=0x0000d000, ready=1 (MSHR has space!)
[CPU] @ cycle 2727: Issue MISS #3 to addr=0x0000e000, ready=1 (MSHR has space!)
[CPU] @ cycle 2729: Issue MISS #4 to addr=0x0000f000, ready=1 (MSHR has space!)

--- Now try MISS #5 (should BLOCK - all 4 MSHRs busy) ---
[CPU] @ cycle 2731: MISS #5 BLOCKED (ready=0, all MSHRs full)

--- Waiting for all outstanding misses to complete ---
    [MEM] Read complete: addr=0x00480
[CPU] @ cycle 2765: MISS response #1 received

>>> MULTI-MSHR SUMMARY:
    - 4 MSHR entries allow 4 outstanding misses
    - Misses 1-4 were accepted without blocking
    - Miss 5 blocked until an MSHR freed up
    - This is MISS-UNDER-MISS (true non-blocking)

╔══════════════════════════════════════════════════════════════════╗
║                    SIMULATION COMPLETE                           ║
╠══════════════════════════════════════════════════════════════════╣
║  Cache Architecture:                                             ║
║    - 4-way set-associative                                       ║
║    - 8 sets × 4 ways × 32-byte lines = 1KB                      ║
║    - Random replacement (LFSR)                                   ║
║    - Write-back policy with dirty bits                           ║
║                                                                  ║
║  Demonstrated Features:                                          ║
║    ✓ Cache hit latency: 1 cycle                                  ║
║    ✓ Cache miss penalty: ~50 cycles                              ║
║    ✓ Conflict misses (5 blocks to 4-way set)                     ║
║    ✓ Memory writes (write-back on eviction)                      ║
║    ✓ Byte/half-word/word access                                  ║
║    ✓ Multi-MSHR (4 entries - configurable)                       ║
║    ✓ Hit-under-miss (service hits while miss pending)            ║
║    ✓ Miss-under-miss (up to 4 outstanding misses)                ║
╚══════════════════════════════════════════════════════════════════╝
verilog/tb_cache.v:738: $finish called at 30415000 (1ps)
