# do Cache_run_msim_rtl_verilog.do
# if ![file isdirectory verilog_libs] {
# 	file mkdir verilog_libs
# }
# 
# vlib verilog_libs/altera_ver
# ** Warning: (vlib-34) Library already exists at "verilog_libs/altera_ver".
# vmap altera_ver ./verilog_libs/altera_ver
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap altera_ver ./verilog_libs/altera_ver 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog  -work altera_ver {/home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/altera_primitives.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:20:57 on Dec 28,2025
# vlog -reportprogress 300 -work altera_ver /home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/altera_primitives.v 
# -- Compiling module global
# -- Compiling module carry
# -- Compiling module cascade
# -- Compiling module carry_sum
# -- Compiling module exp
# -- Compiling module soft
# -- Compiling module opndrn
# -- Compiling module row_global
# -- Compiling module TRI
# -- Compiling module lut_input
# -- Compiling module lut_output
# -- Compiling module latch
# -- Compiling module dlatch
# -- Compiling module prim_gdff
# -- Compiling module dff
# -- Compiling module dffe
# -- Compiling module dffea
# -- Compiling module dffeas
# -- Compiling module dffeas_pr
# -- Compiling module prim_gtff
# -- Compiling module tff
# -- Compiling module tffe
# -- Compiling module prim_gjkff
# -- Compiling module jkff
# -- Compiling module jkffe
# -- Compiling module prim_gsrff
# -- Compiling module srff
# -- Compiling module srffe
# -- Compiling module clklock
# -- Compiling module alt_inbuf
# -- Compiling module alt_outbuf
# -- Compiling module alt_outbuf_tri
# -- Compiling module alt_iobuf
# -- Compiling module alt_inbuf_diff
# -- Compiling module alt_outbuf_diff
# -- Compiling module alt_outbuf_tri_diff
# -- Compiling module alt_iobuf_diff
# -- Compiling module alt_bidir_diff
# -- Compiling module alt_bidir_buf
# -- Compiling UDP PRIM_GDFF_LOW
# -- Compiling UDP PRIM_GDFF_LOW_SCLR_PRIORITY
# -- Compiling UDP PRIM_GDFF_HIGH
# -- Compiling UDP PRIM_GDFF_HIGH_SCLR_PRIORITY
# 
# Top level modules:
# 	global
# 	carry
# 	cascade
# 	carry_sum
# 	exp
# 	soft
# 	opndrn
# 	row_global
# 	TRI
# 	lut_input
# 	lut_output
# 	latch
# 	dlatch
# 	dff
# 	dffe
# 	dffea
# 	dffeas
# 	dffeas_pr
# 	tff
# 	tffe
# 	jkff
# 	jkffe
# 	srff
# 	srffe
# 	clklock
# 	alt_inbuf
# 	alt_outbuf
# 	alt_outbuf_tri
# 	alt_iobuf
# 	alt_inbuf_diff
# 	alt_outbuf_diff
# 	alt_outbuf_tri_diff
# 	alt_iobuf_diff
# 	alt_bidir_diff
# 	alt_bidir_buf
# End time: 19:20:57 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vlib verilog_libs/lpm_ver
# ** Warning: (vlib-34) Library already exists at "verilog_libs/lpm_ver".
# vmap lpm_ver ./verilog_libs/lpm_ver
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap lpm_ver ./verilog_libs/lpm_ver 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog  -work lpm_ver {/home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/220model.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:20:58 on Dec 28,2025
# vlog -reportprogress 300 -work lpm_ver /home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/220model.v 
# -- Compiling module LPM_MEMORY_INITIALIZATION
# -- Compiling module LPM_HINT_EVALUATION
# -- Compiling module LPM_DEVICE_FAMILIES
# -- Compiling module lpm_constant
# -- Compiling module lpm_inv
# -- Compiling module lpm_and
# -- Compiling module lpm_or
# -- Compiling module lpm_xor
# -- Compiling module lpm_bustri
# -- Compiling module lpm_mux
# -- Compiling module lpm_decode
# -- Compiling module lpm_clshift
# -- Compiling module lpm_add_sub
# -- Compiling module lpm_compare
# -- Compiling module lpm_mult
# -- Compiling module lpm_divide
# -- Compiling module lpm_abs
# -- Compiling module lpm_counter
# -- Compiling module lpm_latch
# -- Compiling module lpm_ff
# -- Compiling module lpm_shiftreg
# -- Compiling module lpm_ram_dq
# -- Compiling module lpm_ram_dp
# -- Compiling module lpm_ram_io
# -- Compiling module lpm_rom
# -- Compiling module lpm_fifo
# -- Compiling module lpm_fifo_dc_dffpipe
# -- Compiling module lpm_fifo_dc_fefifo
# -- Compiling module lpm_fifo_dc_async
# -- Compiling module lpm_fifo_dc
# -- Compiling module lpm_inpad
# -- Compiling module lpm_outpad
# -- Compiling module lpm_bipad
# 
# Top level modules:
# 	lpm_constant
# 	lpm_inv
# 	lpm_and
# 	lpm_or
# 	lpm_xor
# 	lpm_bustri
# 	lpm_mux
# 	lpm_decode
# 	lpm_clshift
# 	lpm_add_sub
# 	lpm_compare
# 	lpm_mult
# 	lpm_divide
# 	lpm_abs
# 	lpm_counter
# 	lpm_latch
# 	lpm_ff
# 	lpm_shiftreg
# 	lpm_ram_dq
# 	lpm_ram_dp
# 	lpm_ram_io
# 	lpm_rom
# 	lpm_fifo
# 	lpm_fifo_dc
# 	lpm_inpad
# 	lpm_outpad
# 	lpm_bipad
# End time: 19:20:58 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vlib verilog_libs/sgate_ver
# ** Warning: (vlib-34) Library already exists at "verilog_libs/sgate_ver".
# vmap sgate_ver ./verilog_libs/sgate_ver
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap sgate_ver ./verilog_libs/sgate_ver 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog  -work sgate_ver {/home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/sgate.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:20:58 on Dec 28,2025
# vlog -reportprogress 300 -work sgate_ver /home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/sgate.v 
# -- Compiling module oper_add
# -- Compiling module oper_addsub
# -- Compiling module mux21
# -- Compiling module io_buf_tri
# -- Compiling module io_buf_opdrn
# -- Compiling module oper_mult
# -- Compiling module tri_bus
# -- Compiling module oper_div
# -- Compiling module oper_mod
# -- Compiling module oper_left_shift
# -- Compiling module oper_right_shift
# -- Compiling module oper_rotate_left
# -- Compiling module oper_rotate_right
# -- Compiling module oper_less_than
# -- Compiling module oper_mux
# -- Compiling module oper_selector
# -- Compiling module oper_decoder
# -- Compiling module oper_bus_mux
# -- Compiling module oper_latch
# 
# Top level modules:
# 	oper_add
# 	oper_addsub
# 	mux21
# 	io_buf_tri
# 	io_buf_opdrn
# 	oper_mult
# 	tri_bus
# 	oper_div
# 	oper_mod
# 	oper_left_shift
# 	oper_right_shift
# 	oper_rotate_left
# 	oper_rotate_right
# 	oper_less_than
# 	oper_mux
# 	oper_selector
# 	oper_decoder
# 	oper_bus_mux
# 	oper_latch
# End time: 19:20:58 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vlib verilog_libs/altera_mf_ver
# ** Warning: (vlib-34) Library already exists at "verilog_libs/altera_mf_ver".
# vmap altera_mf_ver ./verilog_libs/altera_mf_ver
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap altera_mf_ver ./verilog_libs/altera_mf_ver 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog  -work altera_mf_ver {/home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/altera_mf.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:20:58 on Dec 28,2025
# vlog -reportprogress 300 -work altera_mf_ver /home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/altera_mf.v 
# -- Compiling module lcell
# -- Compiling module ALTERA_MF_MEMORY_INITIALIZATION
# -- Compiling module ALTERA_MF_HINT_EVALUATION
# -- Compiling module ALTERA_DEVICE_FAMILIES
# -- Compiling module dffp
# -- Compiling module pll_iobuf
# -- Compiling module stx_m_cntr
# -- Compiling module stx_n_cntr
# -- Compiling module stx_scale_cntr
# -- Compiling module MF_pll_reg
# -- Compiling module MF_stratix_pll
# -- Compiling module arm_m_cntr
# -- Compiling module arm_n_cntr
# -- Compiling module arm_scale_cntr
# -- Compiling module MF_stratixii_pll
# -- Compiling module ttn_m_cntr
# -- Compiling module ttn_n_cntr
# -- Compiling module ttn_scale_cntr
# -- Compiling module MF_stratixiii_pll
# -- Compiling module cda_m_cntr
# -- Compiling module cda_n_cntr
# -- Compiling module cda_scale_cntr
# -- Compiling module MF_cycloneiii_pll
# -- Compiling module MF_cycloneiiigl_m_cntr
# -- Compiling module MF_cycloneiiigl_n_cntr
# -- Compiling module MF_cycloneiiigl_scale_cntr
# -- Compiling module cycloneiiigl_post_divider
# -- Compiling module MF_cycloneiiigl_pll
# -- Compiling module altpll
# -- Compiling module altlvds_rx
# -- Compiling module stratix_lvds_rx
# -- Compiling module stratixgx_dpa_lvds_rx
# -- Compiling module stratixii_lvds_rx
# -- Compiling module flexible_lvds_rx
# -- Compiling module stratixiii_lvds_rx
# -- Compiling module stratixiii_lvds_rx_channel
# -- Compiling module stratixiii_lvds_rx_dpa
# -- Compiling module altlvds_tx
# -- Compiling module stratixv_local_clk_divider
# -- Compiling module stratix_tx_outclk
# -- Compiling module stratixii_tx_outclk
# -- Compiling module flexible_lvds_tx
# -- Compiling module dcfifo_dffpipe
# -- Compiling module dcfifo_fefifo
# -- Compiling module dcfifo_async
# -- Compiling module dcfifo_sync
# -- Compiling module dcfifo_low_latency
# -- Compiling module dcfifo_mixed_widths
# -- Compiling module dcfifo
# -- Compiling module altera_syncram_derived
# -- Compiling module altera_syncram_derived_forwarding_logic
# -- Compiling module altaccumulate
# -- Compiling module altmult_accum
# -- Compiling module altmult_add
# -- Compiling module altfp_mult
# -- Compiling module altsqrt
# -- Compiling module altclklock
# -- Compiling module altddio_in
# -- Compiling module altddio_out
# -- Compiling module altddio_bidir
# -- Compiling module altdpram
# -- Compiling module altsyncram
# -- Compiling module altsyncram_body
# -- Compiling module alt3pram
# -- Compiling module parallel_add
# -- Compiling module scfifo
# -- Compiling module altshift_taps
# -- Compiling module a_graycounter
# -- Compiling module altsquare
# -- Compiling module altera_std_synchronizer
# -- Compiling module altera_std_synchronizer_bundle
# -- Compiling module alt_cal
# -- Compiling module alt_cal_mm
# -- Compiling module alt_cal_c3gxb
# -- Compiling module alt_cal_sv
# -- Compiling module alt_cal_av
# -- Compiling module alt_aeq_s4
# -- Compiling module alt_eyemon
# -- Compiling module alt_dfe
# -- Compiling module signal_gen
# -- Compiling module jtag_tap_controller
# -- Compiling module dummy_hub
# -- Compiling module sld_virtual_jtag
# -- Compiling module sld_signaltap
# -- Compiling module altstratixii_oct
# -- Compiling module altparallel_flash_loader
# -- Compiling module altserial_flash_loader
# -- Compiling module alt_fault_injection
# -- Compiling module sld_virtual_jtag_basic
# -- Compiling module altsource_probe
# 
# Top level modules:
# 	lcell
# 	altpll
# 	altlvds_rx
# 	altlvds_tx
# 	dcfifo
# 	altaccumulate
# 	altmult_accum
# 	altmult_add
# 	altfp_mult
# 	altsqrt
# 	altclklock
# 	altddio_bidir
# 	altdpram
# 	alt3pram
# 	parallel_add
# 	scfifo
# 	altshift_taps
# 	a_graycounter
# 	altsquare
# 	altera_std_synchronizer_bundle
# 	alt_cal
# 	alt_cal_mm
# 	alt_cal_c3gxb
# 	alt_cal_sv
# 	alt_cal_av
# 	alt_aeq_s4
# 	alt_eyemon
# 	alt_dfe
# 	sld_virtual_jtag
# 	sld_signaltap
# 	altstratixii_oct
# 	altparallel_flash_loader
# 	altserial_flash_loader
# 	alt_fault_injection
# 	sld_virtual_jtag_basic
# 	altsource_probe
# End time: 19:20:59 on Dec 28,2025, Elapsed time: 0:00:01
# Errors: 0, Warnings: 0
# 
# vlib verilog_libs/altera_lnsim_ver
# ** Warning: (vlib-34) Library already exists at "verilog_libs/altera_lnsim_ver".
# vmap altera_lnsim_ver ./verilog_libs/altera_lnsim_ver
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap altera_lnsim_ver ./verilog_libs/altera_lnsim_ver 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog -sv -work altera_lnsim_ver {/home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/altera_lnsim.sv}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:20:59 on Dec 28,2025
# vlog -reportprogress 300 -sv -work altera_lnsim_ver /home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/altera_lnsim.sv 
# -- Compiling package altera_lnsim_functions
# -- Compiling package altera_generic_pll_functions
# -- Compiling module generic_pll
# -- Importing package altera_lnsim_functions
# -- Importing package altera_generic_pll_functions
# -- Compiling module generic_cdr
# -- Compiling module common_28nm_ram_pulse_generator
# -- Compiling module common_28nm_ram_register
# -- Compiling module common_28nm_ram_block
# -- Compiling module generic_m20k
# -- Compiling module generic_m10k
# -- Compiling module common_28nm_mlab_cell_pulse_generator
# -- Compiling module common_28nm_mlab_latch
# -- Compiling module common_28nm_mlab_cell_core
# -- Compiling module common_porta_latches
# -- Compiling module generic_28nm_hp_mlab_cell_impl
# -- Compiling module common_porta_registers
# -- Compiling module generic_28nm_lc_mlab_cell_impl
# -- Compiling module common_28nm_lutram_register
# -- Compiling module generic_14nm_mlab_cell_impl
# -- Compiling module common_14nm_lutram_register
# -- Compiling module generic_mux
# -- Compiling module generic_device_pll
# -- Compiling module altera_mult_add
# -- Compiling module altera_mult_add_rtl
# -- Compiling module ama_signed_extension_function
# -- Compiling module ama_dynamic_signed_function
# -- Compiling module ama_register_function
# -- Compiling module ama_register_with_ext_function
# -- Compiling module ama_data_split_reg_ext_function
# -- Compiling module ama_coef_reg_ext_function
# -- Compiling module ama_adder_function
# -- Compiling module ama_multiplier_function
# -- Compiling module ama_preadder_function
# -- Compiling module ama_chainout_adder_accumulator_function
# -- Compiling module ama_systolic_adder_function
# -- Compiling module ama_scanchain
# -- Compiling module ama_latency_function
# -- Compiling module altera_pll_reconfig_tasks
# -- Compiling module altera_syncram
# -- Compiling module altera_syncram_forwarding_logic
# -- Compiling module ALTERA_LNSIM_MEMORY_INITIALIZATION
# -- Compiling module altera_stratixv_pll
# -- Compiling module altera_arriav_pll
# -- Compiling module altera_arriavgz_pll
# -- Compiling module altera_cyclonev_pll
# -- Compiling module altera_pll
# -- Compiling module dps_extra_kick
# -- Compiling module dprio_init
# -- Compiling module dps_pulse_gen
# -- Compiling module altera_iopll
# -- Compiling module dps_pulse_gen_iopll
# -- Compiling module twentynm_iopll_arlol
# -- Compiling module fourteennm_altera_iopll
# -- Compiling module dps_pulse_gen_fourteennm_iopll
# -- Compiling package fourteennm_iopll_functions
# -- Compiling module fourteennm_simple_iopll
# -- Importing package fourteennm_iopll_functions
# -- Compiling module fourteennm_sub_iopll
# -- Compiling module twentynm_iopll_ip
# -- Compiling module altera_iopll_rotation_lcells
# -- Compiling module altera_pll_dps_lcell_comb
# -- Compiling module iopll_bootstrap
# 
# Top level modules:
# 	generic_cdr
# 	generic_m20k
# 	generic_m10k
# 	common_porta_latches
# 	generic_28nm_hp_mlab_cell_impl
# 	generic_28nm_lc_mlab_cell_impl
# 	generic_14nm_mlab_cell_impl
# 	generic_mux
# 	generic_device_pll
# 	altera_mult_add
# 	altera_pll_reconfig_tasks
# 	altera_syncram
# 	altera_pll
# 	altera_iopll
# 	fourteennm_altera_iopll
# 	fourteennm_simple_iopll
# End time: 19:21:00 on Dec 28,2025, Elapsed time: 0:00:01
# Errors: 0, Warnings: 0
# 
# vlib verilog_libs/cycloneive_ver
# ** Warning: (vlib-34) Library already exists at "verilog_libs/cycloneive_ver".
# vmap cycloneive_ver ./verilog_libs/cycloneive_ver
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap cycloneive_ver ./verilog_libs/cycloneive_ver 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog  -work cycloneive_ver {/home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/cycloneive_atoms.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:00 on Dec 28,2025
# vlog -reportprogress 300 -work cycloneive_ver /home/rajinthan/altera_lite/25.1std/quartus/eda/sim_lib/cycloneive_atoms.v 
# -- Compiling UDP CYCLONEIVE_PRIM_DFFE
# -- Compiling UDP CYCLONEIVE_PRIM_DFFEAS
# -- Compiling UDP CYCLONEIVE_PRIM_DFFEAS_HIGH
# -- Compiling module cycloneive_dffe
# -- Compiling module cycloneive_mux21
# -- Compiling module cycloneive_mux41
# -- Compiling module cycloneive_and1
# -- Compiling module cycloneive_and16
# -- Compiling module cycloneive_bmux21
# -- Compiling module cycloneive_b17mux21
# -- Compiling module cycloneive_nmux21
# -- Compiling module cycloneive_b5mux21
# -- Compiling module cycloneive_latch
# -- Compiling module cycloneive_routing_wire
# -- Compiling module cycloneive_m_cntr
# -- Compiling module cycloneive_n_cntr
# -- Compiling module cycloneive_scale_cntr
# -- Compiling module cycloneive_pll_reg
# -- Compiling module cycloneive_pll
# -- Compiling module cycloneive_lcell_comb
# -- Compiling module cycloneive_ff
# -- Compiling module cycloneive_ram_pulse_generator
# -- Compiling module cycloneive_ram_register
# -- Compiling module cycloneive_ram_block
# -- Compiling module cycloneive_mac_data_reg
# -- Compiling module cycloneive_mac_sign_reg
# -- Compiling module cycloneive_mac_mult_internal
# -- Compiling module cycloneive_mac_mult
# -- Compiling module cycloneive_mac_out
# -- Compiling module cycloneive_io_ibuf
# -- Compiling module cycloneive_io_obuf
# -- Compiling module cycloneive_ddio_out
# -- Compiling module cycloneive_ddio_oe
# -- Compiling module cycloneive_pseudo_diff_out
# -- Compiling module cycloneive_io_pad
# -- Compiling module cycloneive_asmiblock
# -- Compiling module cycloneive_ena_reg
# -- Compiling module cycloneive_clkctrl
# -- Compiling module cycloneive_rublock
# -- Compiling module cycloneive_apfcontroller
# -- Compiling module cycloneive_termination_ctrl
# -- Compiling module cycloneive_termination_rupdn
# -- Compiling module cycloneive_termination
# -- Compiling module cycloneive_jtag
# -- Compiling module cycloneive_crcblock
# -- Compiling module cycloneive_oscillator
# 
# Top level modules:
# 	cycloneive_dffe
# 	cycloneive_and1
# 	cycloneive_and16
# 	cycloneive_bmux21
# 	cycloneive_b17mux21
# 	cycloneive_nmux21
# 	cycloneive_b5mux21
# 	cycloneive_pll_reg
# 	cycloneive_pll
# 	cycloneive_lcell_comb
# 	cycloneive_ff
# 	cycloneive_ram_block
# 	cycloneive_mac_mult
# 	cycloneive_mac_out
# 	cycloneive_io_ibuf
# 	cycloneive_io_obuf
# 	cycloneive_ddio_out
# 	cycloneive_ddio_oe
# 	cycloneive_pseudo_diff_out
# 	cycloneive_io_pad
# 	cycloneive_asmiblock
# 	cycloneive_clkctrl
# 	cycloneive_rublock
# 	cycloneive_apfcontroller
# 	cycloneive_termination
# 	cycloneive_jtag
# 	cycloneive_crcblock
# 	cycloneive_oscillator
# End time: 19:21:00 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# if {[file exists rtl_work]} {
# 	vdel -lib rtl_work -all
# }
# vlib rtl_work
# vmap work rtl_work
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap work rtl_work 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# 
# vlog  -work work +incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog {/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/cache.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:00 on Dec 28,2025
# vlog -reportprogress 300 -work work "+incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog" /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/cache.v 
# -- Compiling module cache
# 
# Top level modules:
# 	cache
# End time: 19:21:01 on Dec 28,2025, Elapsed time: 0:00:01
# Errors: 0, Warnings: 0
# vlog  -work work +incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog {/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/top_synth.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:01 on Dec 28,2025
# vlog -reportprogress 300 -work work "+incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog" /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/top_synth.v 
# -- Compiling module top_synth
# 
# Top level modules:
# 	top_synth
# End time: 19:21:01 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# vlog  -work work +incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/ip {/home/rajinthan/Workspace/Git/Set-Associative-Cache/ip/issp_debug.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:01 on Dec 28,2025
# vlog -reportprogress 300 -work work "+incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/ip" /home/rajinthan/Workspace/Git/Set-Associative-Cache/ip/issp_debug.v 
# -- Compiling module issp_debug
# 
# Top level modules:
# 	issp_debug
# End time: 19:21:01 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# vlib issp
# ** Warning: (vlib-34) Library already exists at "issp".
# vmap issp issp
# Model Technology ModelSim - Intel FPGA Edition vmap 2020.1 Lib Mapping Utility 2020.02 Feb 28 2020
# vmap issp issp 
# Modifying /home/rajinthan/programs/intelFPGA_lite/ModelSim/modelsim_ase/linuxaloem/../modelsim.ini
# vlog  -work issp +incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp {/home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp/issp.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:01 on Dec 28,2025
# vlog -reportprogress 300 -work issp "+incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp" /home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp/issp.v 
# -- Compiling module issp
# 
# Top level modules:
# 	issp
# End time: 19:21:01 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# vlog  -work issp +incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp/submodules {/home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp/submodules/altsource_probe_top.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:01 on Dec 28,2025
# vlog -reportprogress 300 -work issp "+incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp/submodules" /home/rajinthan/Workspace/Git/Set-Associative-Cache/db/ip/issp/submodules/altsource_probe_top.v 
# -- Compiling module altsource_probe_top
# 
# Top level modules:
# 	altsource_probe_top
# End time: 19:21:01 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vlog  -work work +incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog {/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v}
# Model Technology ModelSim - Intel FPGA Edition vlog 2020.1 Compiler 2020.02 Feb 28 2020
# Start time: 19:21:01 on Dec 28,2025
# vlog -reportprogress 300 -work work "+incdir+/home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog" /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v 
# -- Compiling module tb_cache
# 
# Top level modules:
# 	tb_cache
# End time: 19:21:01 on Dec 28,2025, Elapsed time: 0:00:00
# Errors: 0, Warnings: 0
# 
# vsim -t 1ps -L altera_ver -L lpm_ver -L sgate_ver -L altera_mf_ver -L altera_lnsim_ver -L cycloneive_ver -L rtl_work -L work -L issp -voptargs="+acc"  tb_cache
# vsim -t 1ps -L altera_ver -L lpm_ver -L sgate_ver -L altera_mf_ver -L altera_lnsim_ver -L cycloneive_ver -L rtl_work -L work -L issp -voptargs=""+acc"" tb_cache 
# Start time: 19:21:01 on Dec 28,2025
# Loading work.tb_cache
# Loading work.cache
# 
# add wave *
# view structure
# .main_pane.structure.interior.cs.body.struct
# view signals
# .main_pane.objects.interior.cs.body.tree
# run -all
# 
# ╔══════════════════════════════════════════════════════════════════╗
# ║     4-WAY SET-ASSOCIATIVE CACHE SIMULATION                       ║
# ║     Cache: 1KB (8 sets × 4 ways × 32B lines)                     ║
# ║     Replacement: Random (LFSR)  |  Write Policy: Write-back      ║
# ╚══════════════════════════════════════════════════════════════════╝
# 
# ════════════════════════════════════════════════════════════════════
# TEST 1: CACHE HIT LATENCY DEMONSTRATION
# ════════════════════════════════════════════════════════════════════
# [CPU] Read request: addr=0x00100 (first access - MISS expected)
#     [MEM] Request: addr=0x00008 rw=     READ
#     [MEM] Read complete: addr=0x00008
#   Result: MISS | Latency: 56 cycles | Data: 0x00000008
# [CPU] Read request: addr=0x00100 (same address - HIT expected)
#   Result: HIT  | Latency: 2 cycles | Data: 0x00000008
# [CPU] Read request: addr=0x00104 (same line - HIT expected)
#   Result: HIT  | Latency: 2 cycles | Data: 0x00000008
# 
# >>> Hit Latency: 1 cycle | Miss Penalty: ~50 cycles (memory latency)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 2: DATA SIZE SUPPORT (BYTE / HALF-WORD / WORD)
# ════════════════════════════════════════════════════════════════════
#     [MEM] Request: addr=0x00010 rw=     READ
#     [MEM] Read complete: addr=0x00010
# [CPU] Write BYTE to 0x00200: data=0xAB
#   Result:  HIT
# [CPU] Write HALF-WORD to 0x00202: data=0xCDEF
#   Result:  HIT
# [CPU] Write WORD to 0x00204: data=0x12345678
#   Result:  HIT
# [CPU] Read WORD from 0x00204:
#   Result:  HIT | Data: 0x12345678 (expected: 0x12345678)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 3: CONFLICT MISSES DEMONSTRATION
# ════════════════════════════════════════════════════════════════════
# Cache has 8 sets × 4 ways. Accessing 5 addresses mapping to same set
# will cause conflict misses (exceeds 4-way associativity).
# 
# Address mapping: Set = (addr >> 5) & 0x7
# Addresses that map to SET 0: 0x00000, 0x00100, 0x00200, 0x00300, 0x00400
# (all have bits [7:5] = 000)
# 
# --- Phase 1: Fill all 4 ways of Set 0 ---
# [CPU] Read addr=0x00000 (Set 0, Way 0)
#     [MEM] Request: addr=0x00000 rw=     READ
#     [MEM] Read complete: addr=0x00000
#   Result: MISS | Latency: 56 cycles
# [CPU] Read addr=0x00100 (Set 0, Way 1)
#   Result: HIT  | Latency: 2 cycles
# [CPU] Read addr=0x00200 (Set 0, Way 2)
#   Result: HIT  | Latency: 2 cycles
# [CPU] Read addr=0x00300 (Set 0, Way 3)
#     [MEM] Request: addr=0x00018 rw=     READ
#     [MEM] Read complete: addr=0x00018
#   Result: MISS | Latency: 56 cycles
# 
# --- Phase 2: Access 5th address (CONFLICT MISS - evicts one way) ---
# [CPU] Read addr=0x00400 (Set 0, 5th block - causes eviction!)
#     [MEM] Request: addr=0x00020 rw=     READ
#     [MEM] Read complete: addr=0x00020
#   Result: MISS | Latency: 56 cycles
# 
# --- Phase 3: Re-access evicted address (CONFLICT MISS) ---
# [CPU] Read addr=0x00000 (was in Set 0, but may be evicted)
#     [MEM] Request: addr=0x00040 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00040
#     [MEM] Request: addr=0x00000 rw=     READ
#     [MEM] Read complete: addr=0x00000
#   Result: MISS | Latency: 110 cycles
# 
# >>> Statistics: Hits=2, Misses=4
# >>> This demonstrates CONFLICT MISSES due to limited associativity
# 
# ════════════════════════════════════════════════════════════════════
# TEST 4: MEMORY WRITE-BACK (DIRTY LINE EVICTION)
# ════════════════════════════════════════════════════════════════════
# Write-back cache: dirty lines written to memory on eviction
# 
# --- Step 1: Write data to create dirty line ---
# [CPU] Write addr=0x01000 data=0xDEADBEEF
#     [MEM] Request: addr=0x00080 rw=     READ
#     [MEM] Read complete: addr=0x00080
#   Result: MISS (line is now DIRTY)
# 
# --- Step 2: Force eviction by filling the set ---
# [CPU] Read addr=0x01100 (filling set to force eviction)
#     [MEM] Request: addr=0x00088 rw=     READ
#     [MEM] Read complete: addr=0x00088
#   Result: MISS
# [CPU] Read addr=0x01200 (filling set to force eviction)
#     [MEM] Request: addr=0x00090 rw=     READ
#     [MEM] Read complete: addr=0x00090
#   Result: MISS
# [CPU] Read addr=0x01300 (filling set to force eviction)
#     [MEM] Request: addr=0x00200 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00200
#     [MEM] Request: addr=0x00098 rw=     READ
#     [MEM] Read complete: addr=0x00098
#   Result: MISS
# [CPU] Read addr=0x01400 (filling set to force eviction)
#     [MEM] Request: addr=0x000a0 rw=     READ
#     [MEM] Read complete: addr=0x000a0
#   Result: MISS
# 
# >>> If WRITE(WB) appeared in memory log, write-back occurred!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 5: SEQUENTIAL ACCESS PATTERN (Good Locality)
# ════════════════════════════════════════════════════════════════════
# Accessing 32 consecutive words (spans multiple lines):
#     [MEM] Request: addr=0x00100 rw=     READ
#     [MEM] Read complete: addr=0x00100
#     [MEM] Request: addr=0x00101 rw=     READ
#     [MEM] Read complete: addr=0x00101
#     [MEM] Request: addr=0x00102 rw=     READ
#     [MEM] Read complete: addr=0x00102
#     [MEM] Request: addr=0x00103 rw=     READ
#     [MEM] Read complete: addr=0x00103
#   Total: Hits=28, Misses=4
#   Hit Rate: 87%
#   Avg Hit Latency: 2 cycles
#   Avg Miss Latency: 56 cycles
# 
# ════════════════════════════════════════════════════════════════════
# TEST 6: WRITE THEN READ VERIFICATION
# ════════════════════════════════════════════════════════════════════
# [CPU] Write addr=0x03000 data=0xCAFEBABE
#     [MEM] Request: addr=0x00180 rw=     READ
#     [MEM] Read complete: addr=0x00180
# [CPU] Read addr=0x03000
#   Read data: 0xcafebabe
#   >>> PASS: Data matches!
# 
# [CPU] Write addr=0x03004 data=0x12345678
# [CPU] Read addr=0x03004
#   Read data: 0x12345678
#   >>> PASS: Data matches!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 7: THRASHING PATTERN (Worst Case - Repeated Conflicts)
# ════════════════════════════════════════════════════════════════════
# Repeatedly accessing 5 addresses mapping to same set (4-way cache):
# This causes continuous evictions (thrashing)
# 
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00600 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00600
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00210 rw=     READ
#     [MEM] Read complete: addr=0x00210
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#     [MEM] Request: addr=0x00220 rw=     READ
#     [MEM] Read complete: addr=0x00220
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00220 rw=     READ
#     [MEM] Read complete: addr=0x00220
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#   Results: Hits=8, Misses=12
#   Hit Rate: 40% (expected low due to thrashing)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 8: NON-BLOCKING CACHE BEHAVIOR (MSHR DEMONSTRATION)
# ════════════════════════════════════════════════════════════════════
# Non-blocking cache uses MSHR (Miss Status Holding Register) to:
#   - Track outstanding memory requests
#   - Allow cache to continue processing after miss is issued
#   - Handle memory response asynchronously
# 
# --- Scenario 1: Miss triggers MSHR allocation ---
# [CPU] Read addr=0x05000 (cache miss expected)
#   MSHR will: 1) Store miss info  2) Issue memory request  3) Block CPU
#     [MEM] Request: addr=0x00280 rw=     READ
#     [MEM] Read complete: addr=0x00280
#   Result: MISS | MSHR handled the miss
# 
# --- Scenario 2: Hit while MSHR was previously active ---
# [CPU] Read addr=0x05000 (same line - should hit now)
#   Result:  HIT | Latency: 2 cycles (fast - data in cache)
# 
# --- Scenario 3: Write miss with MSHR (allocate-on-write) ---
# [CPU] Write addr=0x06000 data=0xABCD1234 (write miss)
#   MSHR will: 1) Fetch line  2) Merge write data  3) Mark dirty
#     [MEM] Request: addr=0x00300 rw=     READ
#     [MEM] Read complete: addr=0x00300
#   Result: MISS
# [CPU] Read addr=0x06000 (verify write)
#   Data: 0xabcd1234 (CORRECT)
# 
# --- Scenario 4: MSHR with dirty line eviction (write-back) ---
# [CPU] Write addr=0x07000 data=0xDEAD0001 (create dirty line)
#     [MEM] Request: addr=0x00c00 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00c00
#     [MEM] Request: addr=0x00380 rw=     READ
#     [MEM] Read complete: addr=0x00380
# [CPU] Accessing addresses to force eviction of dirty line...
#   MSHR will: 1) Write-back dirty  2) Fetch new line  3) Complete
#     [MEM] Request: addr=0x00e00 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00e00
#     [MEM] Request: addr=0x00388 rw=     READ
#     [MEM] Read complete: addr=0x00388
#     [MEM] Request: addr=0x00390 rw=     READ
#     [MEM] Read complete: addr=0x00390
#     [MEM] Request: addr=0x00398 rw=     READ
#     [MEM] Read complete: addr=0x00398
#     [MEM] Request: addr=0x003a0 rw=     READ
#     [MEM] Read complete: addr=0x003a0
#   If [MEM] WRITE(WB) appeared above, MSHR handled write-back correctly
# 
# --- Scenario 5: MSHR state transitions ---
# MSHR State Machine:
#   IDLE -> MISS_PENDING: On cache miss, MSHR allocated
#   MISS_PENDING -> WB_PENDING: If evicting dirty line
#   WB_PENDING -> FETCH_PENDING: After write-back complete
#   FETCH_PENDING -> IDLE: After line fetched, request complete
# 
# --- Scenario 6: MSHR timing demonstration ---
# [CPU] Read addr=0x08000 @ cycle 2427
#     [MEM] Request: addr=0x00400 rw=     READ
#     [MEM] Read complete: addr=0x00400
#   Response @ cycle 2484 (total latency: 56 cycles)
#   Breakdown: ~1 cycle miss detect + 50 cycle mem latency + 1 cycle response
# 
# >>> NON-BLOCKING SUMMARY:
#     - MSHR tracks one outstanding miss at a time
#     - Handles read misses, write misses, and write-backs
#     - Memory requests issued asynchronously
#     - Cache returns response when memory completes
# 
# ════════════════════════════════════════════════════════════════════
# TEST 9: HIT-UNDER-MISS (True Non-Blocking Behavior)
# ════════════════════════════════════════════════════════════════════
# This test verifies the cache can service HITS while a MISS is pending.
# A blocking cache would stall all requests during memory fetch.
# 
# --- Setup: Pre-load cache lines in different sets ---
#     [MEM] Request: addr=0x00001 rw=     READ
#     [MEM] Read complete: addr=0x00001
#     [MEM] Request: addr=0x00002 rw=     READ
#     [MEM] Read complete: addr=0x00002
#     [MEM] Request: addr=0x00003 rw=     READ
#     [MEM] Read complete: addr=0x00003
#   Loaded lines at 0x00020 (Set 1), 0x00040 (Set 2), 0x00060 (Set 3)
# 
# --- Hit-Under-Miss Test ---
# 1. Issue READ MISS to trigger memory fetch (takes 50 cycles)
# 2. While miss pending, issue HITs to other cached lines
# 3. Hits should complete in 1 cycle, not wait for miss
# 
# [CPU] @ cycle 2656: Issue MISS to addr=0x09000
#     [MEM] Request: addr=0x00480 rw=     READ
# [CPU] @ cycle 2660: MISS still pending (MSHR busy)...
#       Now issuing HITs to pre-loaded lines:
#       cpu_req_ready = 1 (accepting requests!)
#       HIT 0x00020:  HIT in 2 cycles
#       HIT 0x00040:  HIT in 2 cycles
#       HIT 0x00060:  HIT in 2 cycles
# [CPU] @ cycle 2669: Original MISS completed
# 
# >>> SUCCESS: 3 hits serviced WHILE miss was pending!
# >>> This is TRUE NON-BLOCKING (hit-under-miss) behavior!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 10: MISS-UNDER-MISS (Multi-MSHR - 4 Entries)
# ════════════════════════════════════════════════════════════════════
# This test verifies MULTIPLE OUTSTANDING MISSES can be tracked.
# With 4 MSHR entries, we can issue up to 4 misses before blocking.
# 
# --- Issue 4 MISSES rapidly (should all be accepted) ---
# [CPU] @ cycle 2670: Issue MISS #1 to addr=0x0c000, ready=1
# [CPU] @ cycle 2672: Issue MISS #2 to addr=0x0d000, ready=1 (MSHR has space!)
# [CPU] @ cycle 2674: Issue MISS #3 to addr=0x0e000, ready=1 (MSHR has space!)
# [CPU] @ cycle 2676: Issue MISS #4 to addr=0x0f000, ready=1 (MSHR has space!)
# 
# --- Now try MISS #5 (should BLOCK - all 4 MSHRs busy) ---
# [CPU] @ cycle 2678: MISS #5 BLOCKED (ready=0, all MSHRs full)
# 
# --- Waiting for all outstanding misses to complete ---
#     [MEM] Read complete: addr=0x00480
# [CPU] @ cycle 2712: MISS response #1 received
# 
# >>> MULTI-MSHR SUMMARY:
#     - 4 MSHR entries allow 4 outstanding misses
#     - Misses 1-4 were accepted without blocking
#     - Miss 5 blocked until an MSHR freed up
#     - This is MISS-UNDER-MISS (true non-blocking)
# 
# ╔══════════════════════════════════════════════════════════════════╗
# ║                    SIMULATION COMPLETE                           ║
# ╠══════════════════════════════════════════════════════════════════╣
# ║  Cache Architecture:                                             ║
# ║    - 4-way set-associative                                       ║
# ║    - 8 sets × 4 ways × 32-byte lines = 1KB                      ║
# ║    - Random replacement (LFSR)                                   ║
# ║    - Write-back policy with dirty bits                           ║
# ║                                                                  ║
# ║  Demonstrated Features:                                          ║
# ║    ✓ Cache hit latency: 1 cycle                                  ║
# ║    ✓ Cache miss penalty: ~50 cycles                              ║
# ║    ✓ Conflict misses (5 blocks to 4-way set)                     ║
# ║    ✓ Memory writes (write-back on eviction)                      ║
# ║    ✓ Byte/half-word/word access                                  ║
# ║    ✓ Multi-MSHR (4 entries - configurable)                       ║
# ║    ✓ Hit-under-miss (service hits while miss pending)            ║
# ║    ✓ Miss-under-miss (up to 4 outstanding misses)                ║
# ╚══════════════════════════════════════════════════════════════════╝
# ** Note: $finish    : /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v(738)
#    Time: 29875 ns  Iteration: 0  Instance: /tb_cache
# 1
# Break in Module tb_cache at /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v line 738
# 
# stdin: <EOF>
add wave -position 8  sim:/tb_cache/dut/data_array
restart -f
# Closing VCD file "cache_sim.vcd"
run -all
# 
# ╔══════════════════════════════════════════════════════════════════╗
# ║     4-WAY SET-ASSOCIATIVE CACHE SIMULATION                       ║
# ║     Cache: 1KB (8 sets × 4 ways × 32B lines)                     ║
# ║     Replacement: Random (LFSR)  |  Write Policy: Write-back      ║
# ╚══════════════════════════════════════════════════════════════════╝
# 
# ════════════════════════════════════════════════════════════════════
# TEST 1: CACHE HIT LATENCY DEMONSTRATION
# ════════════════════════════════════════════════════════════════════
# [CPU] Read request: addr=0x00100 (first access - MISS expected)
#     [MEM] Request: addr=0x00008 rw=     READ
#     [MEM] Read complete: addr=0x00008
#   Result: MISS | Latency: 56 cycles | Data: 0x00000008
# [CPU] Read request: addr=0x00100 (same address - HIT expected)
#   Result: HIT  | Latency: 2 cycles | Data: 0x00000008
# [CPU] Read request: addr=0x00104 (same line - HIT expected)
#   Result: HIT  | Latency: 2 cycles | Data: 0x00000008
# 
# >>> Hit Latency: 1 cycle | Miss Penalty: ~50 cycles (memory latency)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 2: DATA SIZE SUPPORT (BYTE / HALF-WORD / WORD)
# ════════════════════════════════════════════════════════════════════
#     [MEM] Request: addr=0x00010 rw=     READ
#     [MEM] Read complete: addr=0x00010
# [CPU] Write BYTE to 0x00200: data=0xAB
#   Result:  HIT
# [CPU] Write HALF-WORD to 0x00202: data=0xCDEF
#   Result:  HIT
# [CPU] Write WORD to 0x00204: data=0x12345678
#   Result:  HIT
# [CPU] Read WORD from 0x00204:
#   Result:  HIT | Data: 0x12345678 (expected: 0x12345678)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 3: CONFLICT MISSES DEMONSTRATION
# ════════════════════════════════════════════════════════════════════
# Cache has 8 sets × 4 ways. Accessing 5 addresses mapping to same set
# will cause conflict misses (exceeds 4-way associativity).
# 
# Address mapping: Set = (addr >> 5) & 0x7
# Addresses that map to SET 0: 0x00000, 0x00100, 0x00200, 0x00300, 0x00400
# (all have bits [7:5] = 000)
# 
# --- Phase 1: Fill all 4 ways of Set 0 ---
# [CPU] Read addr=0x00000 (Set 0, Way 0)
#     [MEM] Request: addr=0x00000 rw=     READ
#     [MEM] Read complete: addr=0x00000
#   Result: MISS | Latency: 56 cycles
# [CPU] Read addr=0x00100 (Set 0, Way 1)
#   Result: HIT  | Latency: 2 cycles
# [CPU] Read addr=0x00200 (Set 0, Way 2)
#   Result: HIT  | Latency: 2 cycles
# [CPU] Read addr=0x00300 (Set 0, Way 3)
#     [MEM] Request: addr=0x00018 rw=     READ
#     [MEM] Read complete: addr=0x00018
#   Result: MISS | Latency: 56 cycles
# 
# --- Phase 2: Access 5th address (CONFLICT MISS - evicts one way) ---
# [CPU] Read addr=0x00400 (Set 0, 5th block - causes eviction!)
#     [MEM] Request: addr=0x00020 rw=     READ
#     [MEM] Read complete: addr=0x00020
#   Result: MISS | Latency: 56 cycles
# 
# --- Phase 3: Re-access evicted address (CONFLICT MISS) ---
# [CPU] Read addr=0x00000 (was in Set 0, but may be evicted)
#     [MEM] Request: addr=0x00040 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00040
#     [MEM] Request: addr=0x00000 rw=     READ
#     [MEM] Read complete: addr=0x00000
#   Result: MISS | Latency: 110 cycles
# 
# >>> Statistics: Hits=2, Misses=4
# >>> This demonstrates CONFLICT MISSES due to limited associativity
# 
# ════════════════════════════════════════════════════════════════════
# TEST 4: MEMORY WRITE-BACK (DIRTY LINE EVICTION)
# ════════════════════════════════════════════════════════════════════
# Write-back cache: dirty lines written to memory on eviction
# 
# --- Step 1: Write data to create dirty line ---
# [CPU] Write addr=0x01000 data=0xDEADBEEF
#     [MEM] Request: addr=0x00080 rw=     READ
#     [MEM] Read complete: addr=0x00080
#   Result: MISS (line is now DIRTY)
# 
# --- Step 2: Force eviction by filling the set ---
# [CPU] Read addr=0x01100 (filling set to force eviction)
#     [MEM] Request: addr=0x00088 rw=     READ
#     [MEM] Read complete: addr=0x00088
#   Result: MISS
# [CPU] Read addr=0x01200 (filling set to force eviction)
#     [MEM] Request: addr=0x00090 rw=     READ
#     [MEM] Read complete: addr=0x00090
#   Result: MISS
# [CPU] Read addr=0x01300 (filling set to force eviction)
#     [MEM] Request: addr=0x00200 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00200
#     [MEM] Request: addr=0x00098 rw=     READ
#     [MEM] Read complete: addr=0x00098
#   Result: MISS
# [CPU] Read addr=0x01400 (filling set to force eviction)
#     [MEM] Request: addr=0x000a0 rw=     READ
#     [MEM] Read complete: addr=0x000a0
#   Result: MISS
# 
# >>> If WRITE(WB) appeared in memory log, write-back occurred!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 5: SEQUENTIAL ACCESS PATTERN (Good Locality)
# ════════════════════════════════════════════════════════════════════
# Accessing 32 consecutive words (spans multiple lines):
#     [MEM] Request: addr=0x00100 rw=     READ
#     [MEM] Read complete: addr=0x00100
#     [MEM] Request: addr=0x00101 rw=     READ
#     [MEM] Read complete: addr=0x00101
#     [MEM] Request: addr=0x00102 rw=     READ
#     [MEM] Read complete: addr=0x00102
#     [MEM] Request: addr=0x00103 rw=     READ
#     [MEM] Read complete: addr=0x00103
#   Total: Hits=28, Misses=4
#   Hit Rate: 87%
#   Avg Hit Latency: 2 cycles
#   Avg Miss Latency: 56 cycles
# 
# ════════════════════════════════════════════════════════════════════
# TEST 6: WRITE THEN READ VERIFICATION
# ════════════════════════════════════════════════════════════════════
# [CPU] Write addr=0x03000 data=0xCAFEBABE
#     [MEM] Request: addr=0x00180 rw=     READ
#     [MEM] Read complete: addr=0x00180
# [CPU] Read addr=0x03000
#   Read data: 0xcafebabe
#   >>> PASS: Data matches!
# 
# [CPU] Write addr=0x03004 data=0x12345678
# [CPU] Read addr=0x03004
#   Read data: 0x12345678
#   >>> PASS: Data matches!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 7: THRASHING PATTERN (Worst Case - Repeated Conflicts)
# ════════════════════════════════════════════════════════════════════
# Repeatedly accessing 5 addresses mapping to same set (4-way cache):
# This causes continuous evictions (thrashing)
# 
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00600 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00600
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00210 rw=     READ
#     [MEM] Read complete: addr=0x00210
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#     [MEM] Request: addr=0x00220 rw=     READ
#     [MEM] Read complete: addr=0x00220
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00220 rw=     READ
#     [MEM] Read complete: addr=0x00220
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#   Results: Hits=8, Misses=12
#   Hit Rate: 40% (expected low due to thrashing)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 8: NON-BLOCKING CACHE BEHAVIOR (MSHR DEMONSTRATION)
# ════════════════════════════════════════════════════════════════════
# Non-blocking cache uses MSHR (Miss Status Holding Register) to:
#   - Track outstanding memory requests
#   - Allow cache to continue processing after miss is issued
#   - Handle memory response asynchronously
# 
# --- Scenario 1: Miss triggers MSHR allocation ---
# [CPU] Read addr=0x05000 (cache miss expected)
#   MSHR will: 1) Store miss info  2) Issue memory request  3) Block CPU
#     [MEM] Request: addr=0x00280 rw=     READ
#     [MEM] Read complete: addr=0x00280
#   Result: MISS | MSHR handled the miss
# 
# --- Scenario 2: Hit while MSHR was previously active ---
# [CPU] Read addr=0x05000 (same line - should hit now)
#   Result:  HIT | Latency: 2 cycles (fast - data in cache)
# 
# --- Scenario 3: Write miss with MSHR (allocate-on-write) ---
# [CPU] Write addr=0x06000 data=0xABCD1234 (write miss)
#   MSHR will: 1) Fetch line  2) Merge write data  3) Mark dirty
#     [MEM] Request: addr=0x00300 rw=     READ
#     [MEM] Read complete: addr=0x00300
#   Result: MISS
# [CPU] Read addr=0x06000 (verify write)
#   Data: 0xabcd1234 (CORRECT)
# 
# --- Scenario 4: MSHR with dirty line eviction (write-back) ---
# [CPU] Write addr=0x07000 data=0xDEAD0001 (create dirty line)
#     [MEM] Request: addr=0x00c00 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00c00
#     [MEM] Request: addr=0x00380 rw=     READ
#     [MEM] Read complete: addr=0x00380
# [CPU] Accessing addresses to force eviction of dirty line...
#   MSHR will: 1) Write-back dirty  2) Fetch new line  3) Complete
#     [MEM] Request: addr=0x00e00 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00e00
#     [MEM] Request: addr=0x00388 rw=     READ
#     [MEM] Read complete: addr=0x00388
#     [MEM] Request: addr=0x00390 rw=     READ
#     [MEM] Read complete: addr=0x00390
#     [MEM] Request: addr=0x00398 rw=     READ
#     [MEM] Read complete: addr=0x00398
#     [MEM] Request: addr=0x003a0 rw=     READ
#     [MEM] Read complete: addr=0x003a0
#   If [MEM] WRITE(WB) appeared above, MSHR handled write-back correctly
# 
# --- Scenario 5: MSHR state transitions ---
# MSHR State Machine:
#   IDLE -> MISS_PENDING: On cache miss, MSHR allocated
#   MISS_PENDING -> WB_PENDING: If evicting dirty line
#   WB_PENDING -> FETCH_PENDING: After write-back complete
#   FETCH_PENDING -> IDLE: After line fetched, request complete
# 
# --- Scenario 6: MSHR timing demonstration ---
# [CPU] Read addr=0x08000 @ cycle 2427
#     [MEM] Request: addr=0x00400 rw=     READ
#     [MEM] Read complete: addr=0x00400
#   Response @ cycle 2484 (total latency: 56 cycles)
#   Breakdown: ~1 cycle miss detect + 50 cycle mem latency + 1 cycle response
# 
# >>> NON-BLOCKING SUMMARY:
#     - MSHR tracks one outstanding miss at a time
#     - Handles read misses, write misses, and write-backs
#     - Memory requests issued asynchronously
#     - Cache returns response when memory completes
# 
# ════════════════════════════════════════════════════════════════════
# TEST 9: HIT-UNDER-MISS (True Non-Blocking Behavior)
# ════════════════════════════════════════════════════════════════════
# This test verifies the cache can service HITS while a MISS is pending.
# A blocking cache would stall all requests during memory fetch.
# 
# --- Setup: Pre-load cache lines in different sets ---
#     [MEM] Request: addr=0x00001 rw=     READ
#     [MEM] Read complete: addr=0x00001
#     [MEM] Request: addr=0x00002 rw=     READ
#     [MEM] Read complete: addr=0x00002
#     [MEM] Request: addr=0x00003 rw=     READ
#     [MEM] Read complete: addr=0x00003
#   Loaded lines at 0x00020 (Set 1), 0x00040 (Set 2), 0x00060 (Set 3)
# 
# --- Hit-Under-Miss Test ---
# 1. Issue READ MISS to trigger memory fetch (takes 50 cycles)
# 2. While miss pending, issue HITs to other cached lines
# 3. Hits should complete in 1 cycle, not wait for miss
# 
# [CPU] @ cycle 2656: Issue MISS to addr=0x09000
#     [MEM] Request: addr=0x00480 rw=     READ
# [CPU] @ cycle 2660: MISS still pending (MSHR busy)...
#       Now issuing HITs to pre-loaded lines:
#       cpu_req_ready = 1 (accepting requests!)
#       HIT 0x00020:  HIT in 2 cycles
#       HIT 0x00040:  HIT in 2 cycles
#       HIT 0x00060:  HIT in 2 cycles
# [CPU] @ cycle 2669: Original MISS completed
# 
# >>> SUCCESS: 3 hits serviced WHILE miss was pending!
# >>> This is TRUE NON-BLOCKING (hit-under-miss) behavior!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 10: MISS-UNDER-MISS (Multi-MSHR - 4 Entries)
# ════════════════════════════════════════════════════════════════════
# This test verifies MULTIPLE OUTSTANDING MISSES can be tracked.
# With 4 MSHR entries, we can issue up to 4 misses before blocking.
# 
# --- Issue 4 MISSES rapidly (should all be accepted) ---
# [CPU] @ cycle 2670: Issue MISS #1 to addr=0x0c000, ready=1
# [CPU] @ cycle 2672: Issue MISS #2 to addr=0x0d000, ready=1 (MSHR has space!)
# [CPU] @ cycle 2674: Issue MISS #3 to addr=0x0e000, ready=1 (MSHR has space!)
# [CPU] @ cycle 2676: Issue MISS #4 to addr=0x0f000, ready=1 (MSHR has space!)
# 
# --- Now try MISS #5 (should BLOCK - all 4 MSHRs busy) ---
# [CPU] @ cycle 2678: MISS #5 BLOCKED (ready=0, all MSHRs full)
# 
# --- Waiting for all outstanding misses to complete ---
#     [MEM] Read complete: addr=0x00480
# [CPU] @ cycle 2712: MISS response #1 received
# 
# >>> MULTI-MSHR SUMMARY:
#     - 4 MSHR entries allow 4 outstanding misses
#     - Misses 1-4 were accepted without blocking
#     - Miss 5 blocked until an MSHR freed up
#     - This is MISS-UNDER-MISS (true non-blocking)
# 
# ╔══════════════════════════════════════════════════════════════════╗
# ║                    SIMULATION COMPLETE                           ║
# ╠══════════════════════════════════════════════════════════════════╣
# ║  Cache Architecture:                                             ║
# ║    - 4-way set-associative                                       ║
# ║    - 8 sets × 4 ways × 32-byte lines = 1KB                      ║
# ║    - Random replacement (LFSR)                                   ║
# ║    - Write-back policy with dirty bits                           ║
# ║                                                                  ║
# ║  Demonstrated Features:                                          ║
# ║    ✓ Cache hit latency: 1 cycle                                  ║
# ║    ✓ Cache miss penalty: ~50 cycles                              ║
# ║    ✓ Conflict misses (5 blocks to 4-way set)                     ║
# ║    ✓ Memory writes (write-back on eviction)                      ║
# ║    ✓ Byte/half-word/word access                                  ║
# ║    ✓ Multi-MSHR (4 entries - configurable)                       ║
# ║    ✓ Hit-under-miss (service hits while miss pending)            ║
# ║    ✓ Miss-under-miss (up to 4 outstanding misses)                ║
# ╚══════════════════════════════════════════════════════════════════╝
# ** Note: $finish    : /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v(738)
#    Time: 29875 ns  Iteration: 0  Instance: /tb_cache
# 1
# Break in Module tb_cache at /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v line 738
add wave -position 169  sim:/tb_cache/dut/tag_array
restart -f
# Closing VCD file "cache_sim.vcd"
run -all
# 
# ╔══════════════════════════════════════════════════════════════════╗
# ║     4-WAY SET-ASSOCIATIVE CACHE SIMULATION                       ║
# ║     Cache: 1KB (8 sets × 4 ways × 32B lines)                     ║
# ║     Replacement: Random (LFSR)  |  Write Policy: Write-back      ║
# ╚══════════════════════════════════════════════════════════════════╝
# 
# ════════════════════════════════════════════════════════════════════
# TEST 1: CACHE HIT LATENCY DEMONSTRATION
# ════════════════════════════════════════════════════════════════════
# [CPU] Read request: addr=0x00100 (first access - MISS expected)
#     [MEM] Request: addr=0x00008 rw=     READ
#     [MEM] Read complete: addr=0x00008
#   Result: MISS | Latency: 56 cycles | Data: 0x00000008
# [CPU] Read request: addr=0x00100 (same address - HIT expected)
#   Result: HIT  | Latency: 2 cycles | Data: 0x00000008
# [CPU] Read request: addr=0x00104 (same line - HIT expected)
#   Result: HIT  | Latency: 2 cycles | Data: 0x00000008
# 
# >>> Hit Latency: 1 cycle | Miss Penalty: ~50 cycles (memory latency)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 2: DATA SIZE SUPPORT (BYTE / HALF-WORD / WORD)
# ════════════════════════════════════════════════════════════════════
#     [MEM] Request: addr=0x00010 rw=     READ
#     [MEM] Read complete: addr=0x00010
# [CPU] Write BYTE to 0x00200: data=0xAB
#   Result:  HIT
# [CPU] Write HALF-WORD to 0x00202: data=0xCDEF
#   Result:  HIT
# [CPU] Write WORD to 0x00204: data=0x12345678
#   Result:  HIT
# [CPU] Read WORD from 0x00204:
#   Result:  HIT | Data: 0x12345678 (expected: 0x12345678)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 3: CONFLICT MISSES DEMONSTRATION
# ════════════════════════════════════════════════════════════════════
# Cache has 8 sets × 4 ways. Accessing 5 addresses mapping to same set
# will cause conflict misses (exceeds 4-way associativity).
# 
# Address mapping: Set = (addr >> 5) & 0x7
# Addresses that map to SET 0: 0x00000, 0x00100, 0x00200, 0x00300, 0x00400
# (all have bits [7:5] = 000)
# 
# --- Phase 1: Fill all 4 ways of Set 0 ---
# [CPU] Read addr=0x00000 (Set 0, Way 0)
#     [MEM] Request: addr=0x00000 rw=     READ
#     [MEM] Read complete: addr=0x00000
#   Result: MISS | Latency: 56 cycles
# [CPU] Read addr=0x00100 (Set 0, Way 1)
#   Result: HIT  | Latency: 2 cycles
# [CPU] Read addr=0x00200 (Set 0, Way 2)
#   Result: HIT  | Latency: 2 cycles
# [CPU] Read addr=0x00300 (Set 0, Way 3)
#     [MEM] Request: addr=0x00018 rw=     READ
#     [MEM] Read complete: addr=0x00018
#   Result: MISS | Latency: 56 cycles
# 
# --- Phase 2: Access 5th address (CONFLICT MISS - evicts one way) ---
# [CPU] Read addr=0x00400 (Set 0, 5th block - causes eviction!)
#     [MEM] Request: addr=0x00020 rw=     READ
#     [MEM] Read complete: addr=0x00020
#   Result: MISS | Latency: 56 cycles
# 
# --- Phase 3: Re-access evicted address (CONFLICT MISS) ---
# [CPU] Read addr=0x00000 (was in Set 0, but may be evicted)
#     [MEM] Request: addr=0x00040 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00040
#     [MEM] Request: addr=0x00000 rw=     READ
#     [MEM] Read complete: addr=0x00000
#   Result: MISS | Latency: 110 cycles
# 
# >>> Statistics: Hits=2, Misses=4
# >>> This demonstrates CONFLICT MISSES due to limited associativity
# 
# ════════════════════════════════════════════════════════════════════
# TEST 4: MEMORY WRITE-BACK (DIRTY LINE EVICTION)
# ════════════════════════════════════════════════════════════════════
# Write-back cache: dirty lines written to memory on eviction
# 
# --- Step 1: Write data to create dirty line ---
# [CPU] Write addr=0x01000 data=0xDEADBEEF
#     [MEM] Request: addr=0x00080 rw=     READ
#     [MEM] Read complete: addr=0x00080
#   Result: MISS (line is now DIRTY)
# 
# --- Step 2: Force eviction by filling the set ---
# [CPU] Read addr=0x01100 (filling set to force eviction)
#     [MEM] Request: addr=0x00088 rw=     READ
#     [MEM] Read complete: addr=0x00088
#   Result: MISS
# [CPU] Read addr=0x01200 (filling set to force eviction)
#     [MEM] Request: addr=0x00090 rw=     READ
#     [MEM] Read complete: addr=0x00090
#   Result: MISS
# [CPU] Read addr=0x01300 (filling set to force eviction)
#     [MEM] Request: addr=0x00200 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00200
#     [MEM] Request: addr=0x00098 rw=     READ
#     [MEM] Read complete: addr=0x00098
#   Result: MISS
# [CPU] Read addr=0x01400 (filling set to force eviction)
#     [MEM] Request: addr=0x000a0 rw=     READ
#     [MEM] Read complete: addr=0x000a0
#   Result: MISS
# 
# >>> If WRITE(WB) appeared in memory log, write-back occurred!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 5: SEQUENTIAL ACCESS PATTERN (Good Locality)
# ════════════════════════════════════════════════════════════════════
# Accessing 32 consecutive words (spans multiple lines):
#     [MEM] Request: addr=0x00100 rw=     READ
#     [MEM] Read complete: addr=0x00100
#     [MEM] Request: addr=0x00101 rw=     READ
#     [MEM] Read complete: addr=0x00101
#     [MEM] Request: addr=0x00102 rw=     READ
#     [MEM] Read complete: addr=0x00102
#     [MEM] Request: addr=0x00103 rw=     READ
#     [MEM] Read complete: addr=0x00103
#   Total: Hits=28, Misses=4
#   Hit Rate: 87%
#   Avg Hit Latency: 2 cycles
#   Avg Miss Latency: 56 cycles
# 
# ════════════════════════════════════════════════════════════════════
# TEST 6: WRITE THEN READ VERIFICATION
# ════════════════════════════════════════════════════════════════════
# [CPU] Write addr=0x03000 data=0xCAFEBABE
#     [MEM] Request: addr=0x00180 rw=     READ
#     [MEM] Read complete: addr=0x00180
# [CPU] Read addr=0x03000
#   Read data: 0xcafebabe
#   >>> PASS: Data matches!
# 
# [CPU] Write addr=0x03004 data=0x12345678
# [CPU] Read addr=0x03004
#   Read data: 0x12345678
#   >>> PASS: Data matches!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 7: THRASHING PATTERN (Worst Case - Repeated Conflicts)
# ════════════════════════════════════════════════════════════════════
# Repeatedly accessing 5 addresses mapping to same set (4-way cache):
# This causes continuous evictions (thrashing)
# 
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00600 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00600
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00210 rw=     READ
#     [MEM] Read complete: addr=0x00210
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#     [MEM] Request: addr=0x00220 rw=     READ
#     [MEM] Read complete: addr=0x00220
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#     [MEM] Request: addr=0x00200 rw=     READ
#     [MEM] Read complete: addr=0x00200
#     [MEM] Request: addr=0x00208 rw=     READ
#     [MEM] Read complete: addr=0x00208
#     [MEM] Request: addr=0x00220 rw=     READ
#     [MEM] Read complete: addr=0x00220
#     [MEM] Request: addr=0x00218 rw=     READ
#     [MEM] Read complete: addr=0x00218
#   Results: Hits=8, Misses=12
#   Hit Rate: 40% (expected low due to thrashing)
# 
# ════════════════════════════════════════════════════════════════════
# TEST 8: NON-BLOCKING CACHE BEHAVIOR (MSHR DEMONSTRATION)
# ════════════════════════════════════════════════════════════════════
# Non-blocking cache uses MSHR (Miss Status Holding Register) to:
#   - Track outstanding memory requests
#   - Allow cache to continue processing after miss is issued
#   - Handle memory response asynchronously
# 
# --- Scenario 1: Miss triggers MSHR allocation ---
# [CPU] Read addr=0x05000 (cache miss expected)
#   MSHR will: 1) Store miss info  2) Issue memory request  3) Block CPU
#     [MEM] Request: addr=0x00280 rw=     READ
#     [MEM] Read complete: addr=0x00280
#   Result: MISS | MSHR handled the miss
# 
# --- Scenario 2: Hit while MSHR was previously active ---
# [CPU] Read addr=0x05000 (same line - should hit now)
#   Result:  HIT | Latency: 2 cycles (fast - data in cache)
# 
# --- Scenario 3: Write miss with MSHR (allocate-on-write) ---
# [CPU] Write addr=0x06000 data=0xABCD1234 (write miss)
#   MSHR will: 1) Fetch line  2) Merge write data  3) Mark dirty
#     [MEM] Request: addr=0x00300 rw=     READ
#     [MEM] Read complete: addr=0x00300
#   Result: MISS
# [CPU] Read addr=0x06000 (verify write)
#   Data: 0xabcd1234 (CORRECT)
# 
# --- Scenario 4: MSHR with dirty line eviction (write-back) ---
# [CPU] Write addr=0x07000 data=0xDEAD0001 (create dirty line)
#     [MEM] Request: addr=0x00c00 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00c00
#     [MEM] Request: addr=0x00380 rw=     READ
#     [MEM] Read complete: addr=0x00380
# [CPU] Accessing addresses to force eviction of dirty line...
#   MSHR will: 1) Write-back dirty  2) Fetch new line  3) Complete
#     [MEM] Request: addr=0x00e00 rw=WRITE(WB)
#     [MEM] Writeback complete: addr=0x00e00
#     [MEM] Request: addr=0x00388 rw=     READ
#     [MEM] Read complete: addr=0x00388
#     [MEM] Request: addr=0x00390 rw=     READ
#     [MEM] Read complete: addr=0x00390
#     [MEM] Request: addr=0x00398 rw=     READ
#     [MEM] Read complete: addr=0x00398
#     [MEM] Request: addr=0x003a0 rw=     READ
#     [MEM] Read complete: addr=0x003a0
#   If [MEM] WRITE(WB) appeared above, MSHR handled write-back correctly
# 
# --- Scenario 5: MSHR state transitions ---
# MSHR State Machine:
#   IDLE -> MISS_PENDING: On cache miss, MSHR allocated
#   MISS_PENDING -> WB_PENDING: If evicting dirty line
#   WB_PENDING -> FETCH_PENDING: After write-back complete
#   FETCH_PENDING -> IDLE: After line fetched, request complete
# 
# --- Scenario 6: MSHR timing demonstration ---
# [CPU] Read addr=0x08000 @ cycle 2427
#     [MEM] Request: addr=0x00400 rw=     READ
#     [MEM] Read complete: addr=0x00400
#   Response @ cycle 2484 (total latency: 56 cycles)
#   Breakdown: ~1 cycle miss detect + 50 cycle mem latency + 1 cycle response
# 
# >>> NON-BLOCKING SUMMARY:
#     - MSHR tracks one outstanding miss at a time
#     - Handles read misses, write misses, and write-backs
#     - Memory requests issued asynchronously
#     - Cache returns response when memory completes
# 
# ════════════════════════════════════════════════════════════════════
# TEST 9: HIT-UNDER-MISS (True Non-Blocking Behavior)
# ════════════════════════════════════════════════════════════════════
# This test verifies the cache can service HITS while a MISS is pending.
# A blocking cache would stall all requests during memory fetch.
# 
# --- Setup: Pre-load cache lines in different sets ---
#     [MEM] Request: addr=0x00001 rw=     READ
#     [MEM] Read complete: addr=0x00001
#     [MEM] Request: addr=0x00002 rw=     READ
#     [MEM] Read complete: addr=0x00002
#     [MEM] Request: addr=0x00003 rw=     READ
#     [MEM] Read complete: addr=0x00003
#   Loaded lines at 0x00020 (Set 1), 0x00040 (Set 2), 0x00060 (Set 3)
# 
# --- Hit-Under-Miss Test ---
# 1. Issue READ MISS to trigger memory fetch (takes 50 cycles)
# 2. While miss pending, issue HITs to other cached lines
# 3. Hits should complete in 1 cycle, not wait for miss
# 
# [CPU] @ cycle 2656: Issue MISS to addr=0x09000
#     [MEM] Request: addr=0x00480 rw=     READ
# [CPU] @ cycle 2660: MISS still pending (MSHR busy)...
#       Now issuing HITs to pre-loaded lines:
#       cpu_req_ready = 1 (accepting requests!)
#       HIT 0x00020:  HIT in 2 cycles
#       HIT 0x00040:  HIT in 2 cycles
#       HIT 0x00060:  HIT in 2 cycles
# [CPU] @ cycle 2669: Original MISS completed
# 
# >>> SUCCESS: 3 hits serviced WHILE miss was pending!
# >>> This is TRUE NON-BLOCKING (hit-under-miss) behavior!
# 
# ════════════════════════════════════════════════════════════════════
# TEST 10: MISS-UNDER-MISS (Multi-MSHR - 4 Entries)
# ════════════════════════════════════════════════════════════════════
# This test verifies MULTIPLE OUTSTANDING MISSES can be tracked.
# With 4 MSHR entries, we can issue up to 4 misses before blocking.
# 
# --- Issue 4 MISSES rapidly (should all be accepted) ---
# [CPU] @ cycle 2670: Issue MISS #1 to addr=0x0c000, ready=1
# [CPU] @ cycle 2672: Issue MISS #2 to addr=0x0d000, ready=1 (MSHR has space!)
# [CPU] @ cycle 2674: Issue MISS #3 to addr=0x0e000, ready=1 (MSHR has space!)
# [CPU] @ cycle 2676: Issue MISS #4 to addr=0x0f000, ready=1 (MSHR has space!)
# 
# --- Now try MISS #5 (should BLOCK - all 4 MSHRs busy) ---
# [CPU] @ cycle 2678: MISS #5 BLOCKED (ready=0, all MSHRs full)
# 
# --- Waiting for all outstanding misses to complete ---
#     [MEM] Read complete: addr=0x00480
# [CPU] @ cycle 2712: MISS response #1 received
# 
# >>> MULTI-MSHR SUMMARY:
#     - 4 MSHR entries allow 4 outstanding misses
#     - Misses 1-4 were accepted without blocking
#     - Miss 5 blocked until an MSHR freed up
#     - This is MISS-UNDER-MISS (true non-blocking)
# 
# ╔══════════════════════════════════════════════════════════════════╗
# ║                    SIMULATION COMPLETE                           ║
# ╠══════════════════════════════════════════════════════════════════╣
# ║  Cache Architecture:                                             ║
# ║    - 4-way set-associative                                       ║
# ║    - 8 sets × 4 ways × 32-byte lines = 1KB                      ║
# ║    - Random replacement (LFSR)                                   ║
# ║    - Write-back policy with dirty bits                           ║
# ║                                                                  ║
# ║  Demonstrated Features:                                          ║
# ║    ✓ Cache hit latency: 1 cycle                                  ║
# ║    ✓ Cache miss penalty: ~50 cycles                              ║
# ║    ✓ Conflict misses (5 blocks to 4-way set)                     ║
# ║    ✓ Memory writes (write-back on eviction)                      ║
# ║    ✓ Byte/half-word/word access                                  ║
# ║    ✓ Multi-MSHR (4 entries - configurable)                       ║
# ║    ✓ Hit-under-miss (service hits while miss pending)            ║
# ║    ✓ Miss-under-miss (up to 4 outstanding misses)                ║
# ╚══════════════════════════════════════════════════════════════════╝
# ** Note: $finish    : /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v(738)
#    Time: 29875 ns  Iteration: 0  Instance: /tb_cache
# 1
# Break in Module tb_cache at /home/rajinthan/Workspace/Git/Set-Associative-Cache/verilog/tb_cache.v line 738
# End time: 20:00:59 on Dec 28,2025, Elapsed time: 0:39:58
# Errors: 0, Warnings: 0
